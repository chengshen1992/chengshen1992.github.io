[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shen Cheng, Ph.D.",
    "section": "",
    "text": "I am a Research Scientist in the field of pharmacometrics. I am currently working as an Assistant Professor in Pharmacometrics at the Department of Experimental and Clinical Pharmacology (ECP), University of Minnesota College of Pharmacy. I am passionate about the development and implementation of innovative pharmacometric methodologies to address clinical needs for the accomplishment of precision medicine.\n \n  \n   \n  \n    \n     Email\n  \n  \n    \n     Github\n  \n  \n    \n     CV\n  \n  \n    \n     Linkedin"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Blogs",
    "section": "",
    "text": "Create reproducible PMx workflow at MSI\n\n\n\n\n\n\n\nworkflow\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nMar 16, 2024\n\n\nShen Cheng\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Reproducible_PMX_workflow/index.html",
    "href": "posts/Reproducible_PMX_workflow/index.html",
    "title": "Create reproducible PMx workflow at MSI",
    "section": "",
    "text": "Pharmacometric (PMx) research usually involves computationally intensive modeling and simulation processes. High performance computing (HPC) systems provided by Minnesota Supercomputing Institute (MSI) serves as a valuable platform to perform PMx research. This blog post illustrates a strategy for constructing a collaborative, reproducible and manageable PMx workflow at MSI, leveraging several open-source tools in R.\n\n\n\nAcknowledgement\nI’d like to thank Mutaz Jaber for several valuable discussions on this topic. I’d like to thank open-source tools developed by MetrumRG and A2-AI.\n\n\n\nExample workflow\nThe project workflow (project-abc) illustrated in this blog was publicly available on University of Minnesota’s Github Enterprise.\n\n\n\n\n1. Connect to VPN\nMSI can only be accessed when\n\nYou are connected to eduroam network on campus.\nYou are off campus but connecting to the University’s Virtual Private Network (VPN). Please make sure when selecting a channel for connection, do NOT select the channel named “UMN - Departmental Pools”.\n\n\n\n\n\n\n\n\n2. Access R at MSI\nSeveral ways are available to access R on MSI. This blog post uses Open OnDemand as the portal for the purpose of illustration.\nFollowing the access to Open Ondemand, choose Rstudio Server under Interactive Apps tab. Then specify the settings for the Rstudio Server session.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlease note:\n\nNONMEM, as the primary PMx modeling platform, has only been installed in HPC mesabi and mangi, not in agate. So if you’d like to use NONMEM, please avoid selecting agate as the cluster.\nSeveral R versions are available, keeping a consistent R version among collaborators would better ensure the reproducibility of the project.\n\nRstudio session will start in a few seconds / minutes (depends on your Rstudio Server settings) after click the “Launch” button.\n\n\n\n\n\n\n\n3. Build a Github repository\nGithub is a useful tool for collaborative coding, facilitating both code review and management. University of Minnesota provides complimentary access to GitHub Enterprise for all students and employees possessing an active Internet ID. Establishing a GitHub repository can significantly improve the efficiency and collaborative experience of a PMx project. While this blog post will not provide a detailed GitHub tutorial, those interested in a comprehensive exploration of its capabilities are encouraged to consult this document for further information. Briefly,\nStep 1: Registering / signing in University of Minnesota GitHub Enterprise. Initialize a new GitHub repository (i.e, project-abc) by clicking “New repository” tab. Then, specify the settings (e.g., name, visibility, etc) and create the repository.\n\n\n\n\n\n\n\n\n\n\nStep 2: If you have already set up your GitHub SSH key. Clone the repository into your MSI Rstudio Server session through “terminal” using the SSH option as shown below. Other options such as HTTP and GITHUB CLI are also available but will not be covered in this blog.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep 3: After git clone, the GitHub repository you created should appear in your MSI disk. You can now interact with your GitHub repository and replies on it to synchronize your work with your collaborators.\n\n\n4. Using renv for package version control\n\n\n\n\n\nrenv is a useful package to create reproducible environment for each R project. Instead of using library of R packages installed globally for every project. renv allows you to create project specific library to ensure the package version consistent across an R project.\n\n\nStep 1: Create an R project\nTo use renv, You need to create an R project (.Rproj) in the cloned GitHub repository.\n\n\n\n\n\n\nStep 2: Initialize renv\nIn your R console, type in renv::init() to initialize the structure of the R environment using renv.\n\n\n\n\n\n\n\nThe structure of the environment includes:\n\n.Rprofile: R session automatically runs this script every time you open this R project (i.e., project-abc.Rproj), this ensures the automatic activation of renv.\nrenv/library: the project specific R package library.\nrenv.lock: a record of R packages installed, including all the dependencies.\n\nStep 3: Install packages\nUsing renv, we can install R packages using renv::install(). For example:\n\nrenv::install(\"mrgsolve\") will install mrgsolve package from CRAN\n\nrenv::install(\"metrumresearchgroup/bbr\") will install latest bbr package from GitHub of metrumresearchgroup\n\nHere, I want to install 5 packages into my project folder:\n\nmrgsolve from CRAN.\ntidyverse from CRAN.\nnmrec from GitHub of metrumresearchgroup.\nbbr from GitHub of metrumresearchgroup.\nhere from CRAN.\n\nI can install them by running:\n```{r}\nrenv::install(\"mrgsolve\", \n              \"tidyverse\", \n              \"metrumresearchgroup/nmrec\",\n              \"metrumresearchgroup/bbr\", \n              \"here\")\n```\nWhen asked whether you want to proceed, simply answer Y (yes) to proceed to the next step. The installation might take a while depending on the size of the packages, whether these packages were cached and the configuration of the Rstudio session. When the installation finishes, you should see all the requested packages installed in the renv/library directory.\nStep 4: Create a snapshot of the installed packages\nrenv::snapshot() allows you to create a snapshot of the installed packages, which enables your collaborators to use renv::restore() to restore the same R packages with the same version from the same source in their Rstudio Server session This would ensure the project reproducibility.\nTo accomplish this, we need to first create a new R script library.R in the project directory. This script does nothing but simply library all the packages installed.\nExample code for library.R: 31b8e172-b470-440e-83d8-e6b185028602:dAB5AHAAZQA6AE8AUQBCAGoAQQBHAEkAQQBOAHcAQQA1AEEARwBVAEEATgBnAEIAagBBAEMAMABBAE8AQQBBADQAQQBEAGcAQQBaAEEAQQB0AEEARABRAEEAWQBRAEEAdwBBAEcAVQBBAEwAUQBBADUAQQBHAE0AQQBPAFEAQgBpAEEAQwAwAEEAWgBnAEIAbQBBAEQAWQBBAE4AdwBCAGoAQQBHAFEAQQBOAEEAQQB3AEEARABRAEEAWgBRAEEAMgBBAEQAQQBBAAoAcABvAHMAaQB0AGkAbwBuADoATgB3AEEAMgBBAEQASQBBAE4AdwBBAD0ACgBwAHIAZQBmAGkAeAA6AAoAcwBvAHUAcgBjAGUAOgBZAEEAQgBnAEEARwBBAEEAZQB3AEIANwBBAEgASQBBAGYAUQBCADkAQQBBAG8AQQBiAEEAQgBwAEEARwBJAEEAYwBnAEIAaABBAEgASQBBAGUAUQBBAG8AQQBHADAAQQBjAGcAQgBuAEEASABNAEEAYgB3AEIAcwBBAEgAWQBBAFoAUQBBAHAAQQBBAG8AQQBiAEEAQgBwAEEARwBJAEEAYwBnAEIAaABBAEgASQBBAGUAUQBBAG8AQQBIAFEAQQBhAFEAQgBrAEEASABrAEEAZABnAEIAbABBAEgASQBBAGMAdwBCAGwAQQBDAGsAQQBDAGcAQgBzAEEARwBrAEEAWQBnAEIAeQBBAEcARQBBAGMAZwBCADUAQQBDAGcAQQBiAGcAQgB0AEEASABJAEEAWgBRAEIAagBBAEMAawBBAEMAZwBCAHMAQQBHAGsAQQBZAGcAQgB5AEEARwBFAEEAYwBnAEIANQBBAEMAZwBBAFkAZwBCAGkAQQBIAEkAQQBLAFEAQQBLAEEARwB3AEEAYQBRAEIAaQBBAEgASQBBAFkAUQBCAHkAQQBIAGsAQQBLAEEAQgBvAEEARwBVAEEAYwBnAEIAbABBAEMAawBBAEMAZwBCAGcAQQBHAEEAQQBZAEEAQQA9AAoAcwB1AGYAZgBpAHgAOgA=:31b8e172-b470-440e-83d8-e6b185028602\nSubsequently, we can run renv::snapshot() in the R console. This will update the renv.lock file in the project folder.\nUsing GitHub to synchronize your renv.lock file with your collaborators, they should now be able to install the same version of packages in their Rstudio Server session using renv::restore() according to the updated renv.lock. Similarly, if they update renv.lock on their end, you could also run renv::restore() to restore their installation.\n\n\n5. Run NONMEM using bbi\nCurrently, NONMEM is the primary PMx model development tool at MSI. PsN is available at MSI to communicate with NONMEM for the execution of model fitting. For this blog post, I’d like to introduce bbi developed by MetrumRG as a tool to interact with NONMEM. Using bbi makes the PMx modeling result post-processing much easier using bbr and other open-source tools developed by MetrumRG.\nLet’s take a model (106.mod) from MetrumRG expo1-nonmem-foce as an example. The original analysis data and model were transferred into our project folder (./data/analysis3.csv and ./model/106.mod). The $DATA block in ./model/106.mod was modified accordingly.\nStep 1: bbi installation\nIt is preferable that bbi is installed once every project by setting bbi.bbi_exe_path in .Rprofile. This can be done by adding the following code in .Rprofile:\n```{r}\noptions(\n  'bbr.bbi_exe_path' = normalizePath(\"bin/bbi\")\n)\n```\nSubsequently, restart R session to change the bbr.bbi_exe_path specified in .Rprofile. bbi can be installed via bbr::use_bbi() in R console according to the bbr.bbi_exe_path. The successful installation of bbi can be verified by running bbr::bbi_version() in R console. If bbi has been installed correctly, it should return a specific version number as shown below.\n\n\n\n\n\nStep 2: Create a bbi configuration file\nTo submit a NONMEM model, you would also need a bbi configuration file (bbi.yaml), which specified the path and version of NONMEM, along with the path of the Message Passing Interface (MPI) for parallel computing. This can be done using the following code in R:\n```{r}\n# NONMEM model directory\n  MODEL_DIR &lt;- here(\"model\") \n# NONMEM installation directory at MSI\n  NONMEM_DIR &lt;- \"/common/software/install/migrated/nonmem\" \n# NONMEM version\n  NONMEM_VERSION &lt;- \"750\" \n# MPI installation directory at MSI\n  MPI_PATH &lt;- \"/common/software/install/migrated.intel/x86_64/2018/impi_msi/compilers_and_libraries_2018.0.128/linux/mpi/intel64/bin/mpiexec\" \n\n# Create `bbi` cinfiguration file in `MODEL_DIR`\nbbi_init(.dir = MODEL_DIR,\n         .nonmem_dir = NONMEM_DIR, \n         .nonmem_version = NONMEM_VERSION, \n         .bbi_args = list(\"mpi_exec_path\" = MPI_PATH))\n```\nThis will add a bbi.yaml file (i.e., bbi configuration file) in the MODEL_DIR.\nStep 3: Submit NONMEM model using bbi\nMSI uses slurm as the queuing system for job submission and scheduling, which makes the NONMEM model submission using bbr::submit_model() become impossible. There are two alternative strategies to submit NONMEM models at MSI using bbi.\n\nSubmit in terminal using a bash script. An example bash script (./model/nm_run.sh) is shown below.\n\n```{bash}\n#!/bin/bash -l\n#SBATCH --time=05:25:00 \n#SBATCH --mem=2g\n#SBATCH --tmp=6g\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=46\n#SBATCH -L nonmem@slurmdb:1\n#SBATCH --mail-type=ALL\n#SBATCH --mail-user=cheng423@umn.edu\n#SBATCH -p amdlarge\ncd $SLURM_SUBMIT_DIR\nmodule load nonmem\n/panfs/jay/groups/35/cheng423/cheng423/learning/project-abc/bin/bbi nonmem run local $1.mod --config /panfs/jay/groups/35/cheng423/cheng423/learning/project-abc/model/bbi.yaml\n```\nMany of the commands used in this bash script are detailed in the MSI. Below, we’ve provided explanations for a few selected that are not covered extensively in the MSI documentation:\n\n#SBATCH -L nonmem@slurmdb:1 specifies a NONMEM license. Currently, two NONMEM licenses are available at MSI, you can specify either #SBATCH -L nonmem@slurmdb:1 or #SBATCH -L nonmem@slurmdb:2.\n#SBATCH -p amdlarge specifies partition of the job. Please refer to this sheet to appropriately select the partition that fits your job.\nmodule load nonmem loads NONMEM program at MSI.\n/panfs/jay/groups/35/cheng423/cheng423/learning/project-abc/bin/bbi specifies the executable path of bbi.\n/panfs/jay/groups/35/cheng423/cheng423/learning/project-abc/model/bbi.yaml specifies the bbi configuration file.\n\nWith this bash script, navigate (cd) inside the MODEL_DIR in terminal, NONMEM model fitting can then be submitted at MSI using command sbatch nm_run.sh 106, where 106 substitutes the $1 in the bash script. After submission, you can use squeue --me in terminal to check run status.\n\nCreate a bash script from a template (./script/slurm-template.txt) and then submit it using an R function (./script/function-model.R) adapted from slurmtools.\n\nTo use this method for the submission of NONMEM models, a few options need to be specified first.\n```{r}\n# set path for `bbi` configuration file\noptions(\"bbi_config_path\" = normalizePath(\"model/bbi.yaml\"))\n\n# set slurm template to create bash script\noptions(\"slurm_job_template_path\" = normalizePath(\"script/slurm-template.txt\"))\n\n# set a folder to contain all .out file generated by slurm\noptions(\"submission_root\" = normalizePath(\"sub\"))\n```\nThis will then allow you to submit a NONMEM model at MSI directly from R using a code snippet like:\n```{r}\n# Read `NONMEM` model using `bbr`\nrunno &lt;- \"106\"\nmod &lt;- new_model(.path = file.path(MODEL_DIR, runno), .overwrite=TRUE)\n\n# Load `submit_nonmem_model` function\nsource(here(\"script/function-model.R\"))\n\nPARTITION = \"msismall\"     # partition at MSI see \"https://www.msi.umn.edu/partitions\"\nNCPU = 4                   # ncpu-per-task\nEMAIL = \"cheng423@umn.edu\" # email to receive slurm notification\n\nsubmit_nonmem_model(.mod = mod, \n                    partition = PARTITION, \n                    ncpu = NCPU, \n                    email = EMAIL)\n\n# Use `squeue --me` in terminal to check run status\n```\nStep 4: Check NONMEM modeling results using bbr\nFollowing the NONMEM modeling via bbi, you can check the model results using the following code:\n```{r}\nmod &lt;- read_model(.path = file.path(MODEL_DIR, runno))\nmod %&gt;% model_summary()\n```\nIf model 106 runs successfully, you should see output similar to this:\n\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.3 (2024-02-29)\nPlatform: x86_64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Chicago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] compiler_4.3.3    fastmap_1.1.1     cli_3.6.2         htmltools_0.5.7  \n [5] tools_4.3.3       rstudioapi_0.15.0 yaml_2.3.8        rmarkdown_2.26   \n [9] knitr_1.45        jsonlite_1.8.8    xfun_0.42         digest_0.6.35    \n[13] rlang_1.1.3       renv_1.0.5        evaluate_0.23"
  }
]